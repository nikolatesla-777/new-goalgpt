const i="/api";async function c(s,e,a=3,t=1e3){try{const r=await fetch(s,e);return!r.ok&&(r.status===502||r.status===503||r.status===504)&&a>0?(await new Promise(n=>setTimeout(n,t)),c(s,e,a-1,t*2)):r}catch(r){if((r.name==="TypeError"||r.name==="AbortError")&&a>0)return await new Promise(n=>setTimeout(n,t)),c(s,e,a-1,t*2);throw r}}async function w(){const s=`${i}/matches/live`,e=new AbortController,a=setTimeout(()=>e.abort(),6e4);try{const t=await c(s,{signal:e.signal});if(clearTimeout(a),!t.ok){const o=await t.text();throw t.status===502||t.status===503||t.status===504?new Error(`HTTP ${t.status}: Backend hazır değil. Lütfen birkaç saniye sonra tekrar deneyin.`):new Error(`HTTP ${t.status}: ${o.substring(0,100)}`)}const r=await t.json();if(!r.success)throw new Error(r.message||"Failed to fetch live matches");if(r.data.err)throw new Error(r.data.err);return{results:Array.isArray(r.data?.results)?r.data.results:[],err:r.data?.err??void 0,total:r.data?.total}}catch(t){throw clearTimeout(a),t.name==="AbortError"?new Error("Request timeout: Canlı maçlar çok uzun sürdü. Lütfen tekrar deneyin."):t}}async function h(s,e){const a=new URLSearchParams;s&&a.append("date",s),e&&a.append("status",e);const t=`${i}/matches/diary?${a}`,r=await c(t);if(!r.ok){const u=await r.text();throw r.status===502||r.status===503||r.status===504?new Error(`HTTP ${r.status}: Backend hazır değil. Lütfen birkaç saniye sonra tekrar deneyin.`):new Error(`HTTP ${r.status}: ${u.substring(0,100)}`)}const n=await r.json();if(!n.success)throw new Error(n.message||"Failed to fetch match diary");const o=n.data;if(o?.err)throw new Error(o.err);return{results:Array.isArray(o?.results)?o.results:[],err:o?.err??void 0,total:o?.total}}async function d(s){const e=new URLSearchParams;s?.date&&e.append("date",s.date),e.append("include_live",String(s.includeLive)),e.append("include_ai",String(s.includeAI)),s?.status&&e.append("status",s.status);const a=`${i}/matches/unified?${e}`,t=new AbortController,r=setTimeout(()=>t.abort(),6e4);try{const n=await c(a,{signal:t.signal});if(clearTimeout(r),!n.ok){const u=await n.text();throw n.status===502||n.status===503||n.status===504?new Error(`HTTP ${n.status}: Backend hazır değil. Lütfen birkaç saniye sonra tekrar deneyin.`):new Error(`HTTP ${n.status}: ${u.substring(0,100)}`)}const o=await n.json();if(!o.success)throw new Error(o.message||"Failed to fetch unified matches");return{results:Array.isArray(o.data?.results)?o.data.results:[],total:o.data?.counts?.total,counts:o.data?.counts}}catch(n){throw clearTimeout(r),n.name==="AbortError"?new Error("Request timeout: Unified matches fetch took too long."):n}}async function f(s,e){const a=`${i}/matches/${s}/live-stats`;try{const t=await fetch(a,{signal:e});if(!t.ok)throw new Error(`HTTP ${t.status}`);return(await t.json()).data}catch(t){if(t.name==="AbortError")return null;throw t}}async function m(s,e){const a=`${i}/matches/${s}/incidents`;try{const t=await fetch(a,{signal:e});if(!t.ok)throw new Error(`HTTP ${t.status}`);return(await t.json()).data}catch(t){if(t.name==="AbortError")return null;throw t}}async function y(s,e){const a=`${i}/teams/${s}`;try{const t=await fetch(a,{signal:e});if(!t.ok)throw t.status===404?new Error("Team not found"):new Error(`HTTP ${t.status}`);return(await t.json()).data}catch(t){if(t.name==="AbortError")return null;throw t}}async function T(s,e,a){let t=`${i}/teams/${s}/fixtures`;try{const r=await fetch(t,{signal:a});if(!r.ok)throw new Error(`HTTP ${r.status}`);return(await r.json()).data}catch(r){if(r.name==="AbortError")return null;throw r}}async function $(s,e,a){let t=`${i}/teams/${s}/standings`;try{const r=await fetch(t,{signal:a});if(!r.ok)throw new Error(`HTTP ${r.status}`);return(await r.json()).data}catch(r){if(r.name==="AbortError")return null;throw r}}async function g(s,e){const a=`${i}/teams/${s}/players`;try{const t=await fetch(a,{signal:e});if(!t.ok)throw new Error(`HTTP ${t.status}`);return(await t.json()).data}catch(t){if(t.name==="AbortError")return null;throw t}}async function E(s,e){const a=`${i}/players/${s}`;try{const t=await fetch(a,{signal:e});if(!t.ok)throw new Error(`HTTP ${t.status}`);return await t.json()}catch(t){if(t.name==="AbortError")return null;throw t}}async function p(s,e){const a=`${i}/leagues/${s}`;try{const t=await fetch(a,{signal:e});if(!t.ok)throw t.status===404?new Error("League not found"):new Error(`HTTP ${t.status}`);return await t.json()}catch(t){if(t.name==="AbortError")return null;throw t}}async function P(s,e,a){let t=`${i}/leagues/${s}/fixtures`;const r=new URLSearchParams;e?.limit&&r.append("limit",e.limit.toString()),e?.status&&r.append("status",e.status);const n=r.toString();n&&(t+=`?${n}`);try{const o=await fetch(t,{signal:a});if(!o.ok)throw new Error(`HTTP ${o.status}`);return await o.json()}catch(o){if(o.name==="AbortError")return null;throw o}}async function k(s,e){const a=`${i}/leagues/${s}/standings`;try{const t=await fetch(a,{signal:e});if(!t.ok)throw new Error(`HTTP ${t.status}`);return await t.json()}catch(t){if(t.name==="AbortError")return null;throw t}}async function b(s=100,e){const a=`${i}/predictions/matched?limit=${s}`;try{const t=await fetch(a,{signal:e});if(!t.ok)throw new Error(`HTTP ${t.status}`);return await t.json()}catch(t){if(t.name==="AbortError")return null;throw t}}async function A(s){const e=`${i}/matches/${s}/full`;try{const a=await fetch(e);if(!a.ok)throw new Error(`HTTP ${a.status}`);return(await a.json()).data||{match:null,stats:[],incidents:[],lineup:null,h2h:null,trend:[],standings:[]}}catch(a){return console.error("[getMatchFull] Error:",a),{match:null,stats:[],incidents:[],lineup:null,h2h:null,trend:[],standings:[]}}}export{$ as a,T as b,g as c,p as d,k as e,P as f,y as g,d as h,b as i,w as j,h as k,E as l,A as m,f as n,m as o};
